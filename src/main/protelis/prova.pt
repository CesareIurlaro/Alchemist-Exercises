module prova


// Calcolo di distanze approssimato (gradiente).
// isSource: se il device corrente e' una sorgente
// metric:   funzione che calcola la distanza dispetto ai vicini del device corrente
// returns:  la lunghezza del cammino minimo nella rete verso una sorgente
def gradient(isSource, metric) {
	// inizializzo la distanza a infinito
	rep (distance <- Infinity) {
		mux (isSource) {
			// le sorgenti hanno distanza 0
			0
		} else {
			// gli altri il minimo dei valori dei vicini sommati alla loro distanza relativa
			minHood(nbr(distance) + metric.apply())
		}
	}
}


// la sorgente e' il nodo 0 (fermo nel mezzo)
let sourceID = 0;
let deviceID = self.getDeviceUID().getId();
let isSource = (deviceID == sourceID);


// salvo la stima di distanza e quella esatta
env.put("distance", self.distanceTo(sourceID));                   // distanza euclidea esatta
env.put("gradient", gradient(isSource, () -> {self.nbrRange()})); // distanza tramite gradiente


// determino un tempo in cui iniziare a muovermi
let timeToGo = if(env.has("timeToGo")) {
	// se ho gia' scelto un tempo, non lo cambio
	env.get("timeToGo")
} else {
	// altrimenti lo scelgo a caso tra 0 e 200
	200*self.nextRandomDouble();
};
env.put("timeToGo", timeToGo); // lo memorizzo


// determino un luogo in cui muovermi, se e' il momento di farlo
if (env.has("target") || self.getCurrentTime() < timeToGo) {
	// se ho gia' scelto un obiettivo o non e' ancora ora, non faccio nulla
	0
} else {
	// altrimenti scelgo un obiettivo a caso tra [-4,-2] e [4,2]
	let x = 8*self.nextRandomDouble()-4;
	let y = 4*self.nextRandomDouble()-2;
	env.put("target", [x,y]);
	0
};
